# 网络

## cookie/session的机制与安全

* https://harttle.land/2015/08/10/cookie-session.html（机制与安全 讲的非常透彻）
* https://blog.csdn.net/malimingwq/article/details/79689050
* https://juejin.im/post/59d1f59bf265da06700b0934（有例子）
* session存在服务器端 内存 或者 Redis 甚至数据库
* session存储完会生成sessionID 并通过setcookie字段 添加cookie
* cookie防篡改 是通过签名技术 对每个cookie项添加签名
* 通常cookie中不存敏感信息 而是只存sessionID 敏感信息存在session中
* cookie不可跨域名使用 但是同一个一级域名下的二级域名(wenku.baidu.com和zhidao.baidu.com)可以通用 可以通过cookie.setDomain(".baidu.com")设置 ,这个cookie就可以在多个二级域名间共享，但是不影响其他cookie
* cookie的路径 比如登录cookie只能在登录页面使用 可以通过cookie.setPath("/login/")，这样这个cookie就只能在login页面使用
* cookie的安全性
  * cookie.setSecure(true) 确保cookie只能通过HTTPS传输
  * cookie.setHttpOnly(true)可以防止XSS攻击 即通过js脚本获取cookie 

## http1.0 http1.1 http2.0 https

* http1.0:需要使用keep-alive参数手动建立长连接。规定浏览器和服务器保持比较短时间的链接，浏览器每次请求都和服务器经过三次握手和慢启动建立TCP链接。
* http1.1：
  * 默认长连接，即允许多次利用单个tcp连接，避免重复握手、慢启动创建连接
  * 支持流水线：复用一个tcp连接，但是若干个请求是串行化处理的，一旦某请求超时，就会出现线头阻塞
  * 支持同时打开多个TCP连接
  * 支持虚拟主机：多个站点可以共享同一个ip和端口
  * 新增状态码100：支持只发送header信息。客户端接收到100，说明有权限，再接着发送请求body
  * 支持分块传输编码
* http2.0：
  * 多路复用：多个请求可以在一个连接上并行执行
  * header压缩：减少数据体积
  * 服务端推送：客户端请求数据时，顺便将一些客户端需要的资源推送到客户端，避免客户端创建更多连接

# 操作系统

## IO模型

* 同步阻塞IO。

  1、线程阻塞在等待数据 和 数据拷贝回用户态上

  ![img](https://pic3.zhimg.com/80/e83d68da03da2e8c1568b4b4b630edfd_hd.jpg)

* 同步非阻塞IO。1、线程发出系统调用，若操作系统没准备好久返回错误码，线程会不断重试 知道数据准备好，并主动将数据拷贝回用户空间。**注意系统调用是立即返回的，属于非阻塞。但对于进程来说，阻塞在了拷贝数据这一块，，无法立即返回数据，所以是同步的**。

  ![img](https://pic1.zhimg.com/80/4bc31cab27a9a732ab7d1ba9e674ed64_hd.jpg)

* 同步IO多路复用 select poll epoll。

  1、**IO多路复用是阻塞的**，主要阻塞在select poll epoll这种系统调用上，而不是阻塞在recvfrom上,因为发出recv系统调用时，数据处在准备好的状态

  2、recvfrom系统调用发出后，进程则阻塞在数据拷贝上。

  ![img](https://pic1.zhimg.com/80/b1ec6a4f16844a27c175d5a6a94cd7f8_hd.jpg)

* 同步信号驱动式IO

* 异步IO。

  1、发起aio_read的系统调用，直接返回，告诉操作系统准备好数据并通知自己；

  2、数据准备好后，应用去处理数据。**拷贝数据是由操作系统自己完成的。**
  
  怎样理解阻塞非阻塞与同步异步的区别？ - 大姚的回答 - 知乎 https://www.zhihu.com/question/19732473/answer/26101328
  
  * IO操作分为两步 系统调用和真正的IO操作（读写数据）
  * 同步IO操作需要主动读写数据，都会阻塞于真正的IO操作（recvfrom）
  * 异步操作只需要IO操作完成的通知，并不主动读写数据

## 同步、异步 阻塞、非阻塞：

* https://www.zhihu.com/question/19732473

* IO都是同步IO，不管是select poll 还是epoll，因为调用会后无法立即得到结果，只有将内核空间的数据复制到用户空间后线程才能返回，期间线程处于挂起状态。只不过epoll的通知方式不同。

* 只有使用了特殊的API才是异步IO

  ![img](https://pic3.zhimg.com/80/7d3eb389b7724878bd7e12ebc6dbcdb5_hd.jpg)

* 异步和同步的区别是调用的时候进程或线程是否挂起，并不是通知方式不同。感觉通知方式只是为了实现这一功能的方法，是结果，不是原因。

* 阻塞和非阻塞的区别是调用后是否立即返回，在复制数据到用户态的阶段它们都是阻塞的，所以不管阻塞非阻塞，只要读写数据的两个环节中有阻塞的，那么就是同步的，即便是IO复用，也是同步的…具体解释建议看一下《unix网络编程》第三版的第六章前半部分

* 同步阻塞 同步非阻塞 异步非阻塞（不存在异步阻塞，阻塞肯定是同步的）

# Java相关

## Java基础

### final的好处

> https://www.jianshu.com/p/1f4b0f98cbf1 final详解

* final修饰的变量不可变，可以保证线程安全；
* final可以避免指令重排序，进而避免变量从构造方法中溢出（详细见参考文章中的**final域重排序规则**）；
* final修饰局部变量，作为编译时常量，编译器会进行常量折叠。
* 使用上，访问局部变量比访问成员变量更快，且保证了该变量被误修改，增强代码可读性。

**java this逃逸问题**

this逃逸是指在构造函数完成之前，其他线程就持有该对象的引用。

```java
public class FinalReferenceEscapeDemo {
    private final int a;
    private FinalReferenceEscapeDemo referenceDemo;

    public FinalReferenceEscapeDemo() {
        a = 1;  //1
        referenceDemo = this; //2 此处会导致this逃逸
    }

    public void writer() {
        new FinalReferenceEscapeDemo();
    }

    public void reader() {
        if (referenceDemo != null) {  //3
            int temp = referenceDemo.a; //4
        }
    }
}
```



通常出现在在构造函数中启动线程或注册监听器。

### volatile

### 基本数据类型和封装类的区别

* int是基本数据类型，仅仅代表数的范围；integer是int的封装类，包含很多与数据有关的方法
* int的默认值是0；而integer的默认值是null
* int的变量名和数值存储在栈内存中；而integer是引用堆内存的一个对象
* int不需要实例化；integer需要实例化，实例化方法有三种
  * integer i = 12 自动装箱 
  * integer i = integer.valueof(12) 手动装箱
  * integer i = new Integer（12） 构造函数
* Integer.valueof(i) 当i的范围为-128 到127时，会存放在常量池中；成为Integer的常量缓冲池，实现是静态内部类IntegerCache

### 抽象类和接口的区别

* 抽象类和接口都不能被实例化

* 抽象类可以有具体 的方法实现，接口不能

* 抽象类可以有成员变量和普通的成员方法，且成员变量可以是任何类型的；而接口中的成员变量只能是public static final类型

* 抽象方法必须是public 或 protected，接口中方法必须是public

* 抽象类可以有静态代码块和静态方法；接口中不能含有静态代码块和静态方法

* 抽象类是单继承的

### Java子类的变量初始化顺序

父类静态变量、静态代码块-》子类静态变量 静态代码块-》父类构造代码块 构造函数-》子类构造代码块 构造函数

### Java的线程池和七个参数

* corePoolSize（核心线程数，线程数目达到corePoolIS则后，会把到达的任务放到缓存队列中）

* maximumPoolSize(最大线程数) 
* keepAliveTime 空闲线程保留时间
* TimeUnit 空闲线程的保留时间单位
* BlockingQueue 工作的阻塞队列
* queueCapacity 队列的容量
* ThreadFactory 用于创建线程的工厂类
* rejectedExecutionhandler 队列已满  而且任务量大于最大线程的异常处理策略 

### 线程的几种状态

* new

* runnable（running ready）获取时间片正在执行 或者调用yield放弃时间片
* waiting 调用Object.wait() thread.join() locksupport.unpark()
* timed_waiting Thread.sleep() object.waiting(time) Thread.join(time) locksupport.parkNanos
*  blocked 等待获取锁 或者object.wait()后 重新竞争锁
*  terminated（线程运行结束）

### sleep/wait/notify/notifyall区别

> https://juejin.im/post/5d7142d35188255a5c6247e9
>
> * wait: 释放当前锁，阻塞直到被notify或notifyAll唤醒，或者超时，或者线程被中断(InterruptedException)
>
> * notify: 任意选择一个（无法控制选哪个）正在这个对象上等待的线程把它唤醒，其它线程依然在等待被唤醒
>
> * notifyAll: 唤醒所有线程，让它们去竞争，不过也只有一个能抢到锁
>
> * sleep: 不是Object中的方法，而是Thread类的静态方法，让当前**线程持有锁**阻塞指定时间

> [https://mayinjian.wordpress.com/2017/11/24/java-%E4%B8%AD-wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB/](https://mayinjian.wordpress.com/2017/11/24/java-中-wait-和-sleep-的区别/)

1. Object类是java所有类的超类，有notify() 、notifyAll() 、wait()、wait(long)，如果调用了对象的wait()方法，那么所在的线程便会处于该对象的等待池中，会释放它锁持有的对象的管程和锁，等待池中的线程不会去竞争该对象的锁，当有线程调用了该对象的notifyAll()，被唤醒的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象，被唤醒的线程相比普通获取锁的线程没有任何优先权，所以这时候就会有不公平的竞争，不管先后，随机一个线程取得该对象。这非公平锁和synchronize 锁以及 ReentranceLock的默认构造函数一样，不过ReentrantLock支持传入true最为构造函数的参数，即可构造一个公平锁。
2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁。
3. Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。但是sleep 只要休眠时间到了，直接继续运行，没有让出锁。

线程的状态切换

![img](https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70)



### Java中的引用器（强弱软虚）

* 强引用：Object o = new Object() 只要强引用存在，GC永远不会回收被引用的对象

* 弱引用：用于描述非必需对象。WeakReference类。当垃圾回收器工作时，不管内存是否足够，都会回收只被弱引用关联的对象。

  - 实例：ThreadLocalMap类

  - ThreadLocal中，获取到线程私有对象是通过线程持有的一个threadLocalMap，然后传入ThreadLocal当做key获取到对象的，这时候就有个问题，**如果你在使用完ThreadLocal之后，将其置为null，这时候这个对象并不能被回收，因为他还有 ThreadLocalMap->entry->key的引用**，直到该线程被销毁，但是这个线程很可能会被放到线程池中不会被销毁，这就产生了内存泄露，jdk是通过弱引用来解决的这个问题的，**entry中对key的引用是弱引用，当你取消了ThreadLocal的强引用之后，他就只剩下一个弱引用了，所以也会被回收。**

    作者：王镜鑫

    链接：https://www.zhihu.com/question/37401125/answer/337717256

    来源：知乎

    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

* 软引用：还有用。但非必需。SoftReference类。当内存紧张时，可以被GC掉。可以很好的解决OOM的问题，适合用来做网页缓存和图片缓存等。现在已经不用，大多用LRUCache

* 虚引用：实际不影响对象的回收。 设置虚引用的目的是希望能在这个对象被收集器回收时收到一个系统通知。

### ThreadLocal实现

threadLocal内部维护了一个Entry数组，并基于开放地址法寻找插入地址

threadLocal使用不当会出现内存泄漏问题，原因是threadLocalMap的key为弱引用，当threadLocal本身被置为null后，key的弱引用就开始发挥作用，当key被垃圾回收掉之后，因为没有手动调用threadLocal.remove操作导致value没有被置为null,存在threadLocalMap指向value的强引用，所以出现内存泄漏。**threadLocal的get put remove等操作都会清理一部分key为null但value不为null的entry，可以一定程度上防止内存泄漏**

### 线程池

> 参考：https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/12
>
> java线程池ThreadPoolExecutor八种拒绝策略浅析：http://www.kailing.pub/article/index/arcid/255.html

why？创建线程和销毁线程的花销比较大。因为创建线程会进行一次系统调用，从用户态切换到内核态。在内核中，操作系统会创建线程的管理单元，设置好线程的执行环境，然后切换回用户态执行线程函数；销毁线程时，需要再进入一次内核态，。。。。

how？从创建好一定数量的线程池中拿去线程；方便管理，可以编写线程池管理代码对池中的线程进行统一管理。

what？线程池主要包含任务组和工作队列

* newSingleThreadExecutor 

* newFixedThreadPool(控制线程最大并发数) 堆积的请求处理队列可能会耗费非常大的内存，甚至OOM，使用无界队列处理请求

* newCachedThreadPool
  * 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
  * （可缓存线程池）线程最大数为Integer.MAX_VALUE,可能会创建数量非常多的线程，甚至OOM。
* newScheduledThreadPool（定长线程池）

线程池的工作队列：

三种策略：

直接提交策略，即SynchronousQueue，新的请求优先加入队列，而不是直接创建新线程；当有第二个请求需要加入队列时，因为无法加入则需要创建新线程处理。

使用无界队列：新请求到来时优先创建线程，如果添加任务的速度远远超过处理任务的速度，可能很快就爆了。

使用有界队列：一般不用，但可以防止资源耗尽的发生。

* ArrayBlockingQueue 有界阻塞队列 FIFO
* LinkedBlockingQueue 吞吐量高于Arra.. FIFO（Executors.newFixedThreadPool()使用的队列，无界队列）
* SynchronousQueue 不存储元素的阻塞队列，某次添加元素后，必须等待其他线程取走才能继续添加。吞吐量高于LinkedBlockingQueue，用于Executors.newCachedThreadPool

**线程池线程数量**：

* **CPU密集型任务**：设置为N+1，减少上下文切换
* **I/O密集型任务**：设置为2N，因为处理IO时不占用CPU

## java集合类

**线程不安全**：ArrayList，HashMap通过操作数实现fail-fast机制

* hashmap arraylist等不能在循环中进行put或者remove操作，必须调用迭代器进行操作，才能保证modCount和expectedCount相等，否则会报并发异常。
* 不能多个线程同时操作进行遍历的put remove操作

**原因**：hashmap hasNext方法会判断操作数是否一致。用for循环倒序删除也可以。

### HashMap为什么线程不安全？

多线程遇到rehash的时候会出现循环连接，get，put的时候寻找next节点出现死循环，导致cpu100%

### HashMap、HashTable、ConcurrentHashMap区别

* 线程安全不同

### HashMap、LinkedHashMap区别

HashMap无法保证插入顺序和访问顺序一致，LinkedHashMap通过维护一条双向链表解决了该问题

### LinkedHashMap实现LRUCache

LRUcache添加元素主要逻辑：

* cache未满时，插入已存在元素，将元素移到最后；
* cache未满时，插入不存在元素，直接插入；
* cache已满时，删除头结点，然后插入。

实现可以同ArrayList模拟。

```java
import java.util.LinkedHashMap;  
import java.util.Map;  
public LRUCache<K, V> extends LinkedHashMap<K, V> {  
  private int cacheSize;  
  public LRUCache(int cacheSize) {  
    super(16, 0.75, true);  
    this.cacheSize = cacheSize;  
  }  

  protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {  
    return size() >= cacheSize;  
  }  
} 
```

## java IO、NIO和AIO

> https://zhuanlan.zhihu.com/p/23488863 Java NIO浅析

* IO以流的方式处理数据，NIO以块的方式处理数据
* 通道：通道是双向的，流是单向的。通道包括套接字通道、filechannel、serversocketchannel（用于给新进的tcp连接创建socketchannel）
* 缓冲区buffer：BIO是将数据直接写入stream对象中，而NIO的数据操作都是在缓冲区中进行的。
* NIO被称作非阻塞IO，通过实现IO多路复用中的适配器模型。线程通过selector监听多个通道channel（设置为非阻塞）的事件，从而使一个线程可以处理多个连接。线程拿到就绪的channel集合后，需要同步通过selectionkey进行后续的IO操作。
  * 只有**套接字**channel才能配置为非阻塞，FileChannel不可以。
* AIO：在NIO基础上引入以异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。进行读写操作，只需调用read或write方法就可以，异步完成。完成后会主动调用回调函数
  * BIO：同步阻塞，适用于连接数目比较小且固定的架构；
  * NIO：同步非阻塞，适用于连接数目多且连接比较短的架构；
  * AIO：异步非阻塞，适用于连接数目多且连接比较长的架构；
  * 同步阻塞IO : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。
  * 同步非阻塞IO: 用户进程发起一个IO操作以后，可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费。 
  * 异步非阻塞IO: 用户进程发起一个IO操作然后，立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类比Future模式。

## java反编译

https://www.coderxing.com/javap-verbose.html javap -verbose -p

## java原子类

java7中原子类通过cas解决并发操作，但是若是多个线程竞争，则会由于循环重试造成性能降低；

java8中引入fetch-and-add操作,底层是Xadd指令，可以达到直接修改并使其他线程立即可见的目的。**注意下方代码是java8 AtomaticInteger的实现，其中虽然使用了CompareAndAwapInt,但是jvm虚拟机维护了一些内部函数(会将一系列自动生成的指令替换为原始函数调用)，并会进行相应的优化，getAndAddInt底层使用xadd。这样做的目的是为了防止底层不支持。** 

参考：

* http://ashkrit.blogspot.com/2014/02/atomicinteger-java-7-vs-java-8.html?m=1

* http://ashkrit.blogspot.com/2017/07/java-intrinsic-magic.html?m=1

```
/**
     * Atomically sets to the given value and returns the old value.
     *
     * @param newValue the new value
     * @return the previous value
     */
    public final int getAndSet(int newValue) {
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    }
    
    public final int getAndSetInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var4));

        return var5;
    }
```

## Java内存模型

### 内存模型

Java内存模型定义了线程从内存中读写变量的规则。

java中线程不能直接操作内存中的变量，而是操作自己的工作内存。线程间交换变量要通过主内存进行。

### 内存区域

线程私有:程序计数器、虚拟机栈、本地方法栈

线程共有：堆、方法区

## Java 类的生命周期：加载、连接（验证、准备、解析）、初始化、卸载

* Java类加载（jvm虚拟机找到需要加载的类，把类的信息加载到jvm方法区，并在堆中实例化对应的class对象，作为方法区中这个类的信息入口）
  * 双亲委派机制
  * 类加载器
    * BootStrap类加载器：加载jvm自身需要的类
    * 扩展类加载器：加载`<JAVA_HOME>/lib/ext`目录下 
    * 系统类加载器（app classloader）：加载classpath下的类
* 连接
  * 验证：验证类是否合法，确保加载的类能被jvm执行
  * 准备：为类中的静态变量设置初始值（基本数据类型的0值）（**声明为final的静态变量会初始化为设置值并放入常量池**）
  * 解析：将类中所有的类名（接口名）、字段名、方法名转换成具体的内存地址
* Java类初始化
  * https://www.cnblogs.com/Qian123/p/5713440.html
    * 执行父类的静态代码块，并初始化父类静态成员变量
    * 执行子类的静态代码块，并初始化子类静态成员变量
    * 执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量
    * 执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量
  * 直接引用和被动引用
    * 直接引用会引起类的初始化
      * 通过new实例化对象、读取或设置类中的静态变量、调用类的静态方法
      * 通过反射执行以上三种行为
      * 初始化子类的时候，触发父类的初始化
      * 作为程序入口（main方法）
    * 被动引用不会引起类的初始化
      * 引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
      * 定义类数组，不会引起类的初始化。
      * 引用类的常量，不会引起类的初始化
* 类的卸载
  * 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
  * 加载该类的ClassLoader已经被回收。
  * 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

## java 类加载

* 双亲委派模型
* 如何实现自定义类加载器
  * 重写loadclass和findclass方法，findclass中是自定义的类加载逻辑
* 如何破坏双亲委派模型
  * 自定义类加载器直接在loadclass中实现类加载逻辑，而不是首先交给父类加载器
  * JNDI、JDBC等服务是由启动类加载器加载的，但是需要反向访问子类加载器中的方法，此时引入了线程上下文类加载器，可以通过父类加载请求子类加载器完成加载动作；
  * OSGI实现模块化部署，是通过自定义类加载器机制，该机制不再是树状结构，而是网状结构。

## Lock与Synchronized

区别在于：lock支持可中断、可绑定多个条件、支持公平锁。

* http://blueskykong.com/2017/05/14/lock/
  * 锁的种类有：可重入锁 读写锁 可中断锁 公平锁 独占锁
  * ReentrantLock:可重入 可中断 公平或非公平 独占锁
  * Synchronized：可重入 不可中断 非公平锁 独占锁
  * Semaphore： 共享锁

* Lock实现：
  * ReentrantLock 内部使用CLH等待队列 当调用lock方法时 会将该线程放入等待队列中， 如果是公平锁 只有队头获得锁，如果是非公平，不管是不是队头都能获取锁
  * acquire 实现：首先调用tryacquire()尝试获取锁，成功则返回；失败则通过addWaiter()方法加入到CLH等待队列末尾，然后调用aquireQueued()获取锁，这时线程会进入CLH队列中休眠等待，直到获取锁了才返回；如果休眠中断，线程需要自己再产生一个中断selfInterrupt()
  * 休眠与唤醒是LockSupport.park(thread)和LockSupport.unpark(thread)。线程休眠是通过park挂起，等待其他线程unpark当前线程。当release一个锁时，会同时释放该线程节点的后继节点。
  * 由于线程被唤醒有两种方式：一种是被其他线程调用unpark();另一种是线程中断，这个时候如果获取不到锁，则需要重新产生中断
  * 非公平锁与公平锁的实现区别在于：非公平锁获取锁时，若锁处于空闲状态，则直接获取锁；若获取失败则加入CLH同步队列，进行排队等待；而公平锁获取锁时，即使锁处于空闲状态，线程也要判断自己是不是队头才能获取锁。**重要：非公平锁主要是针对最新尝试获取锁的线程，可以绕过排队，直接尝试获取锁，但是获取锁失败后依然需要排队等待**

* 锁升级：无锁状、偏向锁、轻量级锁（自旋锁)、重量级锁

  * 轻量级锁：使用CAS操作避免重量级锁使用互斥量的开销

  * 锁升级过程：

    * 偏向锁偏向于第一个获取锁对象的线程，锁进入偏向状态

    * 此时如果有另一个线程尝试获取锁对象，偏向状态结束。撤销偏向或者升级为轻量锁。

    * 升级为轻量锁时，修改标志位，且在虚拟机栈帧中创建lock record，并尝试更新对象的mark word指针指向该lock record；

    * 如果cas操作失败，会首先检查对象的mark word是否指向当前线程的虚拟机栈，是说明当前线程已经拥有锁对象，否说明锁对象被其他线程抢占。此时轻量锁不再有效，要膨胀为重量级锁。

      ![image-20200222173557300](C:\Users\YingpeiWu\AppData\Roaming\Typora\typora-user-images\image-20200222173557300.png)

## semaphore

* https://blog.csdn.net/javazejian/article/details/76167357

## AQS使用与原理

* https://www.cnblogs.com/chengxiao/p/7141160.html
* https://www.cnblogs.com/waterystone/p/4920797.html
* http://blog.11034.org/2016-06/reentrantlock.html
* https://www.jianshu.com/p/cc308d82cc71
* ![img](https://upload-images.jianshu.io/upload_images/2615789-02449dc316fe1de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp)
* AQS锁的种类：
  * 独占锁:  ReentrantLock
  * 共享锁：Semaphore\ReentrantReadWriteLock.ReadLock\CyclicBarrier\CountdownPatch
* CLH同步队列：
  * 用于管理等待锁的线程队列
  * 非阻塞的FIFO队列，使用链表实现，并通过CAS和自旋锁保证节点插入和移除的原子性
  * 是CLH队列锁的一种变种，CLH队列锁自旋在前一个结点对象上，当前一个节点islocked=false，且前一个节点不为null的情况下，跳出自旋
  * condition.await()将线程加入condition等待队列中，而signal将等待队列中的队头取出放在CLH同步队列中，等待下次该线程的await()操作或者lock.unlock()才能解除线程的阻塞状态；
* Condition条件队列和CLH同步队列
  * Condition条件队列是一个单向不含头结点的队列，而CLH同步队列是双向的含头结点的队列
  * 条件队列只在condition。await和signal起作用。同步队列在获取锁的时候起作用，失败进入同步队列为，成功
  * condition.await 将已获得锁的头结点从同步队列转到条件等待队列。condition.signal则是从等待队列中取出，转到同步队列中。
  * https://www.jianshu.com/p/28387056eeb4 condition详解
  * 自旋获取锁示意图：![img](https://upload-images.jianshu.io/upload_images/2615789-3fe83cfaf03a02c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/790/format/webp)

## 深入剖析java并发之阻塞队列LinkedBlockingQueue与ArrayBlockingQueue

* https://blog.csdn.net/javazejian/article/details/77410889
* https://www.cnblogs.com/dragonsuc/p/5167285.html blockingqueue详解
* blocking queue可以用于线程之间传输数据 一些线程作为生产者 一些线程用作消费者
* 位于current包下
* arrayBlockingQueue在生产者写入数据和消费者获取数据用的是同一个锁 这是因为写入和获取足够快，引入锁反而复杂，LinkedBlockingQueue用的两把锁 putlock和takelock，高并发下吞吐量较大
* arrayblockingQueue的长度是固定的，添加删除元素不能产生或销毁额外的对象实例；LinkedBlockingQueue的长度是可变的，添加删除元素需要生成新的node节点，在高并发下，gc工作会受较大影响
* lock关联了两个condition：notfull和notempty（通过lock.newcondition（）获得）。生产者线程添加元素时首先获取锁，再尝试添加元素，如果同步队列已满，调用notfull.await()方法（condition是当前lock的condition），挂起当前线程，释放锁，并把当前线程添加到notfull的condition等待队列中；当消费者线程调用condition.signal()唤醒线程时，会将等待队列的头结点取出，并添加到CLH同步队列中。lock会根据当前是公平锁还是非公平锁操作，公平锁的情况是lock从condition队列中取出线程，判断是不是队头，进行唤醒；非公平锁的情况下，从等待队列中取出的线程不管是不是队头都能获得锁

##  垃圾收集器

GC优化相关参数：-Xms，-Xmx，-XX：NewRatio,-XX:NewSize,-XX:SurvivorRatio

串行、并行、吞吐量优先、并发标记清除、G1

jdk1.7、1.8默认垃圾收集器是parallel Scavenge(新生代)+Parallel Old（老年代）

jdk1.9 G1

### 新生代收集器

* Serial收集器：简单而高效，是运行在client模式下的虚拟机的默认新生代收集器；
  * 主要用于单线程并且内存很小的环境
* ParNew收集器：运行在server模式的虚拟机首选的新生代收集器，Serial收集器的多线程版本
  * Serial和ParNew的新生代都是采用复制算法、老年代版本采用标记整理算法
  * jvm默认的收集器
* Parallel Scavenge收集器：“吞吐量优先”收集器，标记整理

### 老年代收集器

* CMS收集器：Concurrent Mark Sweep。第一款并发收集器，采用*标记-清除*算法
  * 初始标记（直接与root关联的对象，快）、并发标记（遍历，慢）、重新标记（较慢）、并发清除
  * 初始标记和重新标记时会暂停应用线程
  * 并发低停顿收集器。
  * **优点**：并发收集、低停顿
  * **缺点**：牺牲吞吐量、无法清除浮动垃圾
* G1收集器：Garbage First。相比CMS的改进为：
  * 基于"标记整理"，不会产生空间碎片。
  * 精确控制停顿。
  * 设计用来处理大于4GB内存的应用程序，适用于堆内存很大的情况，将堆内存分割成不同的区域，并发的进行垃圾回收

## Spring

spring 基于注解驱动课程，强烈推荐，讲透spring基于注解的使用和原理。 https://www.bilibili.com/video/av71252572?p=7

### 什么是IOC和DI，优缺点？

IOC，控制反转。顾名思义，控制权发生了反转。以前A依赖B，是由A主动创建B对象，现在则是A需要B的时候，由IOC容器主动创建一个B对象给A。

DI，依赖注入。实现IOC的方式就通过依赖注入。

**优点**：便于解耦

**缺点**：引入第三方IOC容器，且对象通过反射生成，损失运行效率，需要额外配置。

### spring 容器有几种，有什么区别？

BeanFactory 工厂类

ApplicationContext - ApplicationContext扩展了BeanFactory接口。

| BeanFactory          | ApplicationContext |
| -------------------- | ------------------ |
| 懒加载               | 即时加载           |
| 显式提供资源         | 自己创建和管理     |
| 不支持国际化         | 支持国际化         |
| 不支持基于依赖的注解 | 支持基于依赖的注解 |

### Spring bean的生命周期

* 容器调用构造函数创建对象
* 设置对象属性
* XXXAware接口执行对应的setXXX方法
  * BeanNameAware
  * BeanFactoryAware
  * ApplicationContextAware
* 后置处理器 在初始化方法之前
* 初始化的几种方式，按照从上到下的顺序：
  * postconstructor注解
  * 继承intializingBean接口 afterPropertiesSet方法
  * @Bean(initMethod="") 指定初始化方法
* 后置处理器 在初始化方法之后
* 销毁的几种方法，按照从上到下的顺序：
  * @PreDestroy
  * 继承disposabBean接口 
  * @Bean(destroyMethod="") 指定销毁方法

https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/SpringInterviewQuestions.md#55-spring-%E4%B8%AD%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F

![img](https://pic1.zhimg.com/80/v2-baaf7d50702f6d0935820b9415ff364c_hd.jpg)

![img](https://pic3.zhimg.com/80/754a34e03cfaa40008de8e2b9c1b815c_hd.jpg)

### Spring Bean的五种作用域

singleton prototype request sesssion global-session

### spring bean的注入方式

* 属性注入方式

* 构造函数注入

* 工厂方法注入

* XXXaware注入。继承XXXaware可以获取iioc容器中的某些底层bean，获取方法是通过XXXAwareProcessor后置处理器取出bean。

  autowired 可以用在变量、方法、构造函数上。

### spring-boot 注册bean的几种方式

https://blog.csdn.net/majunzhu/article/details/79199752

* @Configuration+@Bean的方式注入 
* (@Controller @Service @Repository @Component) +@ComponentScan
* @Import注解可以导入其他类中bean
  * 导入其他类，bean的默认id是全类名
  * 导入继承ImportSelector的class，通过selectImport方法返回组件的全类名数组
  * 导入ImportBeanDefinitionRegister.class,手动获取IOC容器，并注入自定义id的bean
* 通过spring提供的FactoryBean
  * 默认获取到的是工厂bean调用getObject创建的对象
  * 要获得工厂bean本身，需要在id前加个&。

### Spring AOP原理

https://www.imooc.com/video/15690



# Redis

## 资料

掘金小册：https://juejin.im/book/5afc2e5f6fb9a07a9b362527

java redis实现：https://github.com/redisson/redisson

redis面试问题集锦 https://zhuanlan.zhihu.com/p/41951014

## redis 和 memcached的区别

* redis 不仅支持简单的key-value数据类型，还提供list set hash string zset等数据结构
* redis支持数据的持久化，memcached不支持
* redis是单线程 memcached是多线程
* 数据一致性：memcached提供cas保证多线程并发时的数据一致性，redis通过事务确保一串命令的原子性

## Redis内存回收

过期键删除策略：

* 被动删除（惰性删除）、
* 主动删除（定期主动淘汰）：内部维护定时任务，每秒运行10次，删除过期键逻辑采用自适应算法，根据键的过期比例设置快慢两种速率回收键，并在键过期概率不超过25% 时，停止算法
* 内存超过maxmemory限定主动清理，主动清理策略：
  * volatile-lru：只对设置了过期时间的key进行LRU
  * allkeys-lru:根据LRU算法删除所有key
  * volatile-random：随机删除即将过期key
  * allkeys-random：随机删除所有键
  * volatile-ttl：删除即将过期的
  * noeviction：永不过期，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息，此时只响应读操作

## redis事务

Redis事务如何处理？怎么保证事物之间不受影响

- Redis事务的分析及改进 https://segmentfault.com/a/1190000002594059
- 只保证一致性和隔离性 不保证原子性和持久性
- 原子性：redis事务执行遇到错误不会回滚，而是继续执行后续命令；
- 持久性：redis使用的持久化模式有三种：内存模式、RDB模式、AOF模式。
  - RDB模式下，服务器在事务执行之后、RDB文件更新之前的这段时间失败，所以RDB模式下的Redis事务也是不持久的。
  - AOF模式下，服务器在命令执行成功和数据保存到硬盘之间，也是有时间间隔的

Redis事务与MySql的区别

- MySQL实现事务，是基于`UNDO/REDO日志`。通过begin rollback commit。默认每个sql都是一个事务，并自动commit。
- redis是基于commands队列。默认不开启。通过watch监控key 通过multi开启事务 exec执行 discard取消

## redis分布式锁：

### 分布式锁的四个条件：

* 互斥性。在任意时刻，只要一个客户端能获得锁。
* 不会发生死锁。及时有一个客户端获取锁之后没有主动解锁，也不会影响后续其他客户端获取锁。通过set原子指令保证原子性
* 性能。
* 可重入。也叫递归锁，同一个线程可以重复获得同一个资源的锁

分布式锁实现参考：

* http://blueskykong.com/2018/01/06/redislock/#more
* https://www.cnblogs.com/number7/p/8320259.html java redission锁实现

* https://mp.weixin.qq.com/s/gOYWLg3xYt4OhS46woN_Lg
  * lua脚本保证释放锁时的原子性
  * redlock算法
* 官方文档关于锁的标准实现：http://redis.cn/topics/distlock.html
* http://zhangtielei.com/posts/blog-redlock-reasoning.html

### 单点redis锁实现：

1. 通过setnx原子指令进行加锁，随机值在所有客户端必须是唯一的，

   ```lua
   SET resource_name my_random_value NX PX 30000
   ```

2. 释放锁时检查随机值，然后进行删除操作，这两步需要通过lua脚本保证原子性

   ```lua
   if redis.call("get",KEYS[1]) == ARGV[1] then
       return redis.call("del",KEYS[1])
   else
       return 0
   end
   ```

***关键点：随机值和lua脚本。***

* 随机值是为了避免删除其他客户端获取成功的锁。如果value是一个定值，则如果客户端A获取到锁之后因为某种原因阻塞；锁超时后被另一个客户端B获得；如果此时客户端A进行释放锁操作，那就会将B的锁删除

* lua脚本也是为了避免删除其他客户端获取成功的锁。如果释放锁操作不是原子性，则如果客户端A执行get请求，并判断随机数与预期值相等后，因为某种原因阻塞了；锁超时后被另一个客户端B获得；如果此时客户端A进行释放锁操作，那就会将B的锁删除

### redlock分布式锁实现步骤

。。。

## Lua脚本优点

* 减少网路开销
* 原子操作
* 复用

## Redis的Scan命令与keys命令

scan是非阻塞的是扫描命令，需要手动去重，而keys会导致线上服务停顿 

## redis 集群

**主从模式**、**哨兵模式**、**集群模式**。

redi	s sentinal着眼于高可用，在master宕机时，会将slave提升为master

redis cluster 着眼于扩展性，在单个redis内存不足时，使用cluster进行分片存储

Redis的哨兵机制

Redis的发布订阅机制

## select、poll或epoll

* 每次调用select都会将所有的文件描述符（fd_set）从用户空间拷贝到内核空间 操作系统进行遍历
  * 缺点1：有数量限制
  * 缺点2：拷进拷出
  * 缺点3：操作系统需要全局扫描哪些文件描述符是就绪（读就绪或者写就绪）的 如果有连接 拷贝回用户态 用户态进行全局扫描 
* poll没有数量限制
* epoll ：在内核中维护一个存储文件描述符的红黑树 用户将文件描述符拷贝到红黑树中，红黑树中的节点使用callback表示文件描述符可用，并拷贝节点信息到链表中，内核将该包含所有可用文件描述符的链表拷贝回用户态，用户只需要遍历这个链表即可。
  * 优点1：不用拷进拷出。epoll_create创建一个epoll句柄，epoll_ctl注册新的事件到epoll句柄中，会把所有的fd拷贝进内核，而且保证只拷贝一次，并指定回调函数。 epoll_ctl函数注册要监听的事件类型
  * 优点2：不用全局扫描。设备就绪时会调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。epoll_wait只需要在被唤醒时，查看就虚链表是否为空即可。
* 应用场景：select适合实时要求高的场景 timeout参数精度为1ns，poll适用于描述符数量较多，且实时要求不高的场景，epoll只能用于linux ，且适用于长连接，描述符数量大、变化少的场景

## Redis Sorted set

* zadd key score value：key是有序集合的名字 score用于排序 value是存储的member，不允许重复
* 底层实现：当items小于64时 采用ziplist实现；大于64改为skiplist和字典同时实现
* 字典和跳跃表共享对象

redis有五种数据类型，若干种编码方式

## Redis AOF重写

* 通过追加log的方式，完成对数据库的备份
* AOF重写启动方式：1、用户手动执行BGREWRITEAOF命令去重写；2、增长百分比为100%的时候启动重写（需满足三个条件：1、BGSAVE不在执行； 2、BGREWRITEAOF没在执行； 3、 AOF文件大小超出1MB（太小没有必要重写））
* AOF重写实现：
  * 因为AOF的目的是保存数据库的状态，重复操作的比如插入修改等指令并不是关键，AOF重写只需要读取数据库的当前状态，比如执行zadd 有序集合中现存的所有成员
  * 一句话总结：根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理 
* AOF重写过程：
  * 主进程fork子进程进行重写，重写过程中的写入指令 一方面追加到现有AOF文件中；一方面添加到AOF重写缓存（重写完成后启用）
  * 重写完成后，子进程发送给主进程完成信号，主进程将AOF重写缓存中的指令追加到新的AOF文件中
  * 新AOF文件改名并覆盖现有AOF文件

# 操作系统

进程间的通信方式：

- 管道及命名管道
- 信号
- 消息队列
- 共享内存
- 信号量
- 套接字

线程同步的方式：

互斥量（互斥对象机制，只有拥有互斥对象的线程才有获得公共资源的权限，保证公共资源不会被多个线程访问）、信号量（控制同一时刻访问资源的线程最大数量）、事件（信号）

进程调度策略：

先来先服务、短执行进程优先、最高优先级优先、

基于进程的静态优先级进行调度（静态优先级一旦确定始终不变、调度性能不高）

动态优先级的调度策略。动态优先级由进程战友CPU的时间长短和就绪进程等待CPU的时间长短来决定。系统开销稍大。

时间片轮转法。进程在就绪队列中的等待时间和享受服务的时间成比例。

页面置换算法：

最优置换算法、

FIFO先进先出算法。该算法只有在按线性顺序访问地址空间才是理想的。

LRU（最近最久未使用）、

LFT（最少使用次数）

## 死锁

四个条件：

* 互斥
* 请求与保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放
* 不可剥夺
* 循环等待

死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与恢复策略

* 死锁预防：从源头预防，性能较低
  * 对于请求和保持条件，破坏它可以通过 每个进程执行前请求所有资源
  * 对于循环等待条件，破坏它可以通过给资源编号，进程只能按编号顺序请求资源。
* 死锁避免：比死锁预防允许更多的并发，允许前三个必要条件
  * 进程启动拒绝：如果一个进程的启动会导致加锁，则不启动

    * 安全状态的检测 类似死锁检测，若存在某种调度次序满足所有进程对资源的需求，则状态安全

  * 资源分配拒绝：如果一个进程的资源请求会导致死锁，则不允许分配，此为银行家算法

    银行家算法允许进程动态地申请资源，系统在每次实施资源分配之前，先计算资源分配的安全性，若此次资源分配安全（通过安全性算法检测），便进行此次分配

    * 单个资源的银行家算法
      * 检测请求是否会导致不安全状态
    * 多个资源的银行家算法
      * 类似于多个资源的死锁检测

* 死锁检测：允许死锁发生，可通过手段检测死锁位置
  * 每种类型一个资源的死锁检测：检测链表环路
  * 每种类型多个资源的死锁检测：
    * 每个进程开始不被标记
    * 每次寻找一个未被标记的进程，且该进程请求的资源数量小于资源总量；返回1
    * 若找不到，算法终止！

* 死锁清除：与死锁检测配合使用，清除死锁
  * 死锁检测和清除实现难度最大，但资源利用率和吞吐量较好
  * 常用的死锁解除方法：
    * 剥夺资源
    * 撤销进程

## 数据库

* ACID 原子性 一致性 隔离性 持久性：
  * 原子性。事务要么执行成功，要么执行失败
  * 一致性。事务执行前后，应该保持一致性状态
  * 隔离性。事务执行成功前，所做修改不应该被其他事务看到
  * 持久性。一旦事务提交，其所做更改将永远保存到数据库。可通过数据库备份和恢复来实现。

  无并发情况下，事务串行执行，原子性可以保证一致性；

  并发情况下，原子性和隔离性共同保证一致性

  持久性防止数据库崩溃

* 并发一致性问题

  * 丢失修改。事务一覆盖了事务二的修改
  * 脏读。读到其他事物为提交的数据
  * 不可重复读。事务重复读取的结果不一致
  * 幻读。读取范围数据时，得到的结果不一致。比如求count

  并发一致性问题主要是因为破坏了事务的隔离性而导致，可以通过事务隔离级别来解决（其实是通过并发控制保证隔离性，并发控制可以通过封锁实现，但是数据库提供的事务隔离级别，可以让用户更轻松的实现隔离性）

* 封锁：粒度有行级锁，表锁(行锁是针对索引加的锁，只有通过索引检索数据，innodb才使用行级锁)

  * 封锁类型：X锁（排它锁，只允许当前事务读和写） S锁（共享锁	只允许当前事务读和其他事务读）
    * select...for update
    * select...lock in shard mode
  * 临时锁和持久锁：有效时期到当前语句结束还是当前事务结束
  * 运用X锁和S锁，何时申请 持续时间 何时释放等 需要封锁协议去控制
    * 一级封锁协议
    * 二级封锁协议
    * 三级封锁协议
    * 两段锁协议，可能导致死锁

* 事务隔离级别

  * 未提交读 ：解决丢失修改问题。实现：通过对写操作加持续X锁实现，阻塞其他事务写但不阻塞读
  * 已提交读 解决脏读。实现：通过对写操作加持续-X锁，阻塞其他事务写和读
  * 可重复读 解决不可重复读。实现：通过对读操作加临时-S锁，阻塞写操作，对写操作加持续-X锁
  * 可串行化 解决幻读。实现：可以通过写操作加持续-X锁，读操作加持续-S锁

  通过乐观锁或悲观锁解决丢失修改问题：

  * 乐观锁通过增加版本号列（如时间戳）检查时间戳改变
  * 悲观锁则通过提交修改时，先加锁查询（select...for update nowait）是否有更新，然后提交修改

* 死锁

  * InnoDB处理死锁的方式是通过检测拥有最少行级排它锁的事务 进行回滚

* 事务日志

  * 存储引擎在修改数据时，只需修改内存拷贝中的数据，同时将该修改行为记录到硬盘上的事务日志中。不用管该修改什么时候持久到磁盘，可以提高事务执行效率。
  * 数据未写回磁盘而崩溃时，存储引擎重启后可以自动恢复。
  * 事务日志采取的是追加的方式

## SQL

where 过滤行 group by过滤分组

```sql
SELECT col, COUNT(*) AS num
FROM mytable
WHERE col > 2
GROUP BY col
HAVING num >= 2;
```

Group By默认会按照分组字段排序 可以通过制定Order By指定排序字段

```
SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col
ORDER BY num;
```

## 多版本并发控制MVCC

MVCC是MySQL中实现提交读和可重复读两种事务隔离级别的实现方式。

通过版本号实现，包括系统版本号和事务版本号，以及每行记录后有两个隐藏列 创建版本号和删除版本号

读数据分为快照读和当前读

## Next-Key Locks

MySQL的InnoDB存储引擎的一种锁实现，可以解决幻读，使用MVCC加Record Locks

Next-Key Locks可以锁定一个范围，通过record lock锁定记录的索引，通过Gap Locks锁定索引之间的间隙

select c from ... where c between 1 and 10 for update

**锁的算法**：

* 记录锁。加载索引记录上的锁，是行锁，使用索引作为where的过滤条件时，加记录锁；如果不用索引，则加表锁
* 间隙锁。锁定范围
* next-key lock。上述两种锁的结合，锁定当前行，以及当前行前边的间隙。

## InnoDB和MyISAM的区别

InnoDB特性：基于MVCC实现高并发，并实现四种事务隔离级别，默认级别是可重复读，并可以通过next-key lock策略防止幻读的出现，这种锁不仅锁行，还锁间隙，防止幻影行的插入。

InnoDB的表示基于聚簇索引建立的，对主键查询有很高的性能。二级索引必须包含主键列，所以主键列要尽可能小。

一些优化：磁盘读取数据时的可预测性预读、自动创建自适应hash索引、加速插入操作的插入缓冲区

InnoDB 支持事务处理与外键和行级锁，MyISAM是表锁，且不支持事务和外键

MyISAM强调的是性能，每次查询具有原子性，执行速度比InnoDB快

MyISAM的索引和数据是分开的，存放在内存中的是索引，且索引可以压缩，占用内存少

InnoDB存放在内存中的是索引+数据。

MyISAM支持全文索引，InnoDB不支持

**对比**：InnoDB适合写密集的表，MyISAM适合读密集的表

### 索引的优点

* 大大减少服务器需要扫描的数据行数
* 帮助服务器避免进行排序和分组，以及避免创建临时表
* 将随机IO变为顺序IO

### 索引的使用场景

* 非常小的表，全局扫描更有优势
* 大到中型的表，索引较有效

### 优化数据访问

减少请求的数据量；减少服务端扫描的行数（覆盖索引）

### 重构查询方式

1、切分大查询；

2、分解大连接查询

* 让缓存更高效
* 分解成多个单表查询
* 减少锁竞争
* 在应用层进行连接，更容易对数据库进行拆分

## 复制

主从复制：

* binlog线程，将主服务器对数据的更改写入log
* I/O线程：从主服务器读取二进制log，写入从服务器中的重放log（replay log）
* SQL线程：读取重放日志，并重放其中的SQL语句![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/master-slave.png)

读写分离：主服务器读（实时性要求较高的读操作）/写 从服务器读

## 索引

聚集索引：聚集索引规定数据在表中的物理存储顺序，InnoDB引擎支持聚集索引

非聚集索引：使用二叉树，且叶子结点不存储数据行，而是存储指向数据行的指针

主索引和辅助索引，主索引为主键索引，叶子结点存储数据行，辅助索引叶子结点存放主键的值

覆盖索引：可以只通过辅助索引就可以查询到的记录，而不需要通过主键索引

联合索引：通过多个列组成索引

* 索引顺序是ab 则查询a或者 ab可以用联合索引 select from where a =  and b = 
* 联合索引的第二个好处是对第二个键值做了排序 。select from where a = order by b.

## http

http请求报文包含请求行 首部行 空行 实体主体

* 请求行（方法+url+http版本）
* 首部行
  * host：url所在的主机
  * connection：是否在连接后关闭
* 实体主体

**put和post的区别**：

使用两者取决于Restful服务时是否幂等，如果需要创建多个对象用post，需要创建单个对象用put

* put用于上传对象到服务器，是幂等操作，对一个uri传输一个对象，具体是创建还是更新（覆盖已有的对象）由返回状态码表示。

* post用于上传对象的时候，不是幂等操作，会产生额外的对象那个

**HTTP/1.0 与 HTTP/1.1**

* 默认长连接
* 支持同时打开多个tcp连接
* 增加100状态码
* 支持管线化处理
* 支持虚拟主机（可以使一台主机拥有多个域名，逻辑上可以看做多个服务器）
* 支持分块传输编码

**https**:

采用隧道进行通信，http先和ssl通信，ssl再和tcp通信

* http的安全性问题：
  * 使用明文，可能被窃听
  * 没有身份认证，通信方的身份可能遭遇伪装
  * 报文可能被篡改
* 校验ca证书：
  * ca证书中包括公钥和hash算法，通过公钥对私钥加密的hash值进行解密，再对该值通过hash算法生成新的hash值，与原hash值比较，相等则通过验证

* https通过认证仿伪装，通过加密防窃听和防篡改
  * 加密采用对称加密和非对称加密
    * https采用对称加密和非对称加密混合的方式进行加密，
      * 通过非对称加密产生三个随机数和ca证书校验，得到对话密钥
        * 客户端首先产生一个随机数1，并将自己支持的ssl版本号和加密算法告诉服务器
        * 服务器确认双方的加密算法，并生成随机数2，把ca证书和随机数2 一同返回给客户端
        * 客户端对ca证书进行校验，通过后产生随机数3，并用公钥对随机数3进行加密，发送给服务端
        * 服务端对随机数3 进行解密，得到真正的随机数3.客户端和服务端利用这三个随机数生成对话密钥，之后就利用对话密钥进行加解密，采用的加密算法是对称加密AES。
      * 之后采用对称加密AES算法进行通信
  * 认证采用证书的方式

## 网络

子网掩码：子网掩码是32位二进制值，它屏蔽掉IP地址中的一部分，可以分离处网络地址和主机地址 ip地址的前三个字节，末位为0.利用子网掩码可以分离出主机地址（子网掩码取反后与ip与运算）和网络地址（子网掩码与ip与运算）

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

上面的子网共有2^2=4-2 = 2个 ，即01 和 10

缺省子网掩码：

* A类：255.0.0.0
* B类：255.255.0.0
* C类：255.255.255.0

ip地址编址方式：

* 分类ABCD
* 子网划分

## 计算机网络体系结构

![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/426df589-6f97-4622-b74d-4a81fcb1da8e.png)

![img](https://github.com/CyC2018/CS-Notes/raw/master/pics/d4eef1e2-5703-4ca4-82ab-8dda93d6b81f.png)

## ping

ping是ICMP的一个重要应用，主要用来测试两台主机间的连通性。

ping的原理是通过向目标主机发送echo请求报文，目的主机收到报文后发送echo回答报文。

## TCP与UDP

UDP首部字段只有8个字节 ：源端口、目的端口、长度、checksum

TCP首部字段有32个字节：源端口 目的端口、序号（发送时） 确认号（接受时） 确认ack 同步syn 终止fin 窗口

tcp三次握手：

* 发送方发出SYN	seq =x  从closed状态进入SYN_SENT状态 
* 接收方收到发送方报文 发出 ACK和SYN seq=y ack=x+1 由listen状态进入SYN_RCVD状态
* 发送方收到 发出ACK seq = x+1 ack=y+1，并进入established状态
* 接收方收到后，进入established状态

第三次握手的原因是为了防止客户端的滞留请求多次发送到服务器，导致打开多个连接

tcp四次挥手：

> https://app.getpocket.com/read/2930773017
>
> * time_wait状态会持续2MSL时长，一是为了防止接受方未收到ack，重发fin报文；二是因为报文有效期为2MSL，避免重启发送方后收到之前的报文。
> * **LAST_ACK**会自动消失。
> * close_wait会占用接受方的文件描述符，当接受方出现大量close_wait状态的连接时，将无法建立新连接。（接收方需要监听发送方连接套接字的EPOLLRDHUP事件，并close文件描述符）

![img](https://pocket-image-cache.com//filters:no_upscale()/https%3A%2F%2Fpic4.zhimg.com%2Fv2-cca52ad65861f73fc6dbb5a80bf09fd3_r.jpg)

* 发送方发送fin 进入**FIN_WAIT1**状态
* 接收方发送ack ，并从**established**状态进入**close_wait**状态
* 发送方收到ack进入**FIN_WAIT2**状态
* 接收方发送fin报文，进入**LAST_ACK**状态(接受方主动调用close方法)
* 发送方发出ack报文，并进入time_wait状态（持续2MSL）。（若服务器没有收到ack，会重发fin报文；收到则进入closed状态）



tcp通过超时重传进行可靠传输，通过滑动窗口实现流量控制

tcp拥塞控制：慢开始、拥塞避免、快重传、快恢复

**TCP和UDP的区别：**

**DNS**：



# Linux

## 指令

ls -l : 按行打开所有文件

ls -a: 显示包含隐藏文件在内的所有文件

ls -la : 显示所有

ls -lh:可以显示文件大小

ls -lS: 根据文件大小排序

ls -ltr：根据修改日期排序

Linux相关：

top查看进程资源占用情况；

netstat 查看端口

ps aux | grep java 查看进程

kill -9 pid 强制终止 kill -3 pid 生成线程dump文件

使用JDK自带的Jconsole，可视化工具，可以检测内存、死锁等

Jstack是Jdk自带的命令行工具，可以查看线程dump

jmap打印堆dump

jvisualvm用来加载dump文件进行分析，也可以远程监控服务器。



**inode：**

硬盘格式化的时候，操作系统会将硬盘分为两个区域、数据区和inode区（存放指向block的索引）

df -i 查看inode节点总数和已经使用的数量

stat命令查看某个文件的inode信息 ，

通过文件名打开文件过程：

系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。

读权限r只能获取文件名；执行权限x可以读取inode节点的信息

硬链接可以使多个文件名指向相同inode，软连接相当于快捷方式

git revert 和 git reset区别：

git revert 使用逆向commit中和之前的提交 和老的branch合并后，这部分commit就不会出现了， git reset 则是撤销commit ，这样与老的branch合并后 ，这部分commit还会出现

# 分布式系统

https://aws.amazon.com/cn/builders-library/?cards-body.sort-by=item.additionalFields.customSort&cards-body.sort-order=asc 亚马逊官方博客

# 代码重构

## solid 原则

单一功能、开闭原则、里式替换、接口隔离、依赖反转

## 设计模式

https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/state.html

优化if lese [http://yihuawanglv.github.io/2016/02/02/java-%E4%BB%8E%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8E%BB%E9%99%A4if-else/](http://yihuawanglv.github.io/2016/02/02/java-从代码中去除if-else/)

策略模式优化if-else https://blog.csdn.net/Zhenxue_Xu/article/details/88782540

# 博客

https://news.ycombinator.com/item?id=22273224

https://eli.thegreenplace.net/

jvm系列文章 https://shipilev.net/jvm/anatomy-quarks/

搜索引擎 https://www.iaria.org/conferences2018/filesDBKDA18/AndreasSchmidt_Tutorial_SearchEngine.pdf